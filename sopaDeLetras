//1. Core Data Structures

typedef struct {
    char escribe[11];  // Stores the word (10 letters + null terminator)
    int largo;         // Actual word length
    int direction;     // 0 = horizontal, 1 = vertical
} Palabra;

int size;              // Grid dimensions (size x size)
int nPalabras;         // Number of words to place
Palabra* palabras;     // Array of word structures
char** grid;           // 2D grid for final word placement
int*** heatmap;        // 3D array: [row][col][letter index (0-25)]
int** totalHeat;       // 2D array: total possibilities per cell

//2. Grid Initialization

void initializeGrid() {
    // Allocate rows
    grid = malloc(size * sizeof(char*));

    for (int i = 0; i < size; i++) {
        // Allocate columns
        grid[i] = malloc(size * sizeof(char));

        // Initialize all cells as empty ('.')
        memset(grid[i], '.', size);
    }
}

//3. Heatmap Initialization

void initializeHeatmap() {
    // Allocate rows for heatmap
    heatmap = malloc(size * sizeof(int**));
    // Allocate rows for totalHeat
    totalHeat = malloc(size * sizeof(int*));

    for (int i = 0; i < size; i++) {
        // Allocate columns for heatmap
        heatmap[i] = malloc(size * sizeof(int*));
        // Allocate columns for totalHeat
        totalHeat[i] = malloc(size * sizeof(int));

        for (int j = 0; j < size; j++) {
            // Allocate 26 ints for A-Z possibilities
            heatmap[i][j] = calloc(26, sizeof(int));
            // Initialize total possibilities to 0
            totalHeat[i][j] = 0;
        }
    }
}

//4. Heatmap Recomputation

void recomputeHeatmap(int* placed) {
    // Reset entire heatmap to zero
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            for (int k = 0; k < 26; k++) {
                heatmap[i][j][k] = 0;
            }
            totalHeat[i][j] = 0;
        }
    }

    // Process each word
    for (int idx = 0; idx < nPalabras; idx++) {
        // Skip already placed words
        if (placed[idx]) continue;

        Palabra p = palabras[idx];
        char upperWord[11];

        // Convert word to uppercase
        for (int i = 0; i < p.largo; i++) {
            upperWord[i] = toupper(p.escribe[i]);
        }

        // Process horizontal words
        if (p.direction == 0) {
            // Try every possible starting position
            for (int i = 0; i < size; i++) {
                for (int j = 0; j <= size - p.largo; j++) {
                    int valid = 1;

                    // Check if placement is valid
                    for (int k = 0; k < p.largo; k++) {
                        // Skip if cell is empty, but conflict if occupied with different letter
                        if (grid[i][j + k] != '.' &&
                            grid[i][j + k] != upperWord[k]) {
                            valid = 0;
                            break;
                        }
                    }

                    // If valid, update heatmap
                    if (valid) {
                        for (int k = 0; k < p.largo; k++) {
                            int lidx = upperWord[k] - 'A';
                            heatmap[i][j + k][lidx]++;  // Increment letter count
                            totalHeat[i][j + k]++;       // Increment cell total
                        }
                    }
                }
            }
        }
        // Process vertical words (same logic as horizontal)
        else {
            for (int i = 0; i <= size - p.largo; i++) {
                for (int j = 0; j < size; j++) {
                    int valid = 1;
                    for (int k = 0; k < p.largo; k++) {
                        if (grid[i + k][j] != '.' &&
                            grid[i + k][j] != upperWord[k]) {
                            valid = 0;
                            break;
                        }
                    }
                    if (valid) {
                        for (int k = 0; k < p.largo; k++) {
                            int lidx = upperWord[k] - 'A';
                            heatmap[i + k][j][lidx]++;
                            totalHeat[i + k][j]++;
                        }
                    }
                }
            }
        }
    }
}

//5. Placement Score Calculation

double calculatePlacementScore(int wordIdx, int row, int col) {
    Palabra p = palabras[wordIdx];
    char upperWord[11];

    // Convert word to uppercase
    for (int i = 0; i < p.largo; i++) {
        upperWord[i] = toupper(p.escribe[i]);
    }

    double disruption = 0;

    // Calculate disruption for each letter position
    for (int k = 0; k < p.largo; k++) {
        // Calculate position in grid
        int r = row + (p.direction ? k : 0);
        int c = col + (p.direction ? 0 : k);

        // Only count disruption for empty cells
        if (grid[r][c] == '.') {
            int lidx = upperWord[k] - 'A';
            // Disruption = total possibilities - possibilities for this letter
            disruption += totalHeat[r][c] - heatmap[r][c][lidx];
        }
    }

    // Calculate distance to grid center
    double center = (size - 1) / 2.0;
    double wordCenterX = row + (p.direction ? (p.largo - 1)/2.0 : 0);
    double wordCenterY = col + (p.direction ? 0 : (p.largo - 1)/2.0);
    double distance = sqrt(pow(wordCenterX - center, 2) + pow(wordCenterY - center, 2));

    // Combined score (disruption + distance penalty)
    return disruption + distance;
}

//6. Main Placement Algorithm

void placeWords() {
    // Track which words are placed
    int* placed = calloc(nPalabras, sizeof(int));
    int placedCount = 0;

    // Initialize data structures
    initializeGrid();
    initializeHeatmap();
    recomputeHeatmap(placed);

    while (placedCount < nPalabras) {
        int minPlacements = INT_MAX;  // Start with max possible value
        int candidate = -1;           // Index of most constrained word

        // Find most constrained word (fewest valid placements)
        for (int idx = 0; idx < nPalabras; idx++) {
            if (placed[idx]) continue;

            int placements = 0;
            Palabra p = palabras[idx];

            // Count valid horizontal placements
            if (p.direction == 0) {
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j <= size - p.largo; j++) {
                        int valid = 1;
                        for (int k = 0; k < p.largo; k++) {
                            char c = toupper(p.escribe[k]);
                            if (grid[i][j + k] != '.' && grid[i][j + k] != c) {
                                valid = 0;
                                break;
                            }
                        }
                        placements += valid;
                    }
                }
            }
            // Count valid vertical placements (similar logic)
            else {
                for (int j = 0; j < size; j++) {
                    for (int i = 0; i <= size - p.largo; i++) {
                        int valid = 1;
                        for (int k = 0; k < p.largo; k++) {
                            char c = toupper(p.escribe[k]);
                            if (grid[i + k][j] != '.' && grid[i + k][j] != c) {
                                valid = 0;
                                break;
                            }
                        }
                        placements += valid;
                    }
                }
            }

            // Update most constrained candidate
            if (placements < minPlacements) {
                minPlacements = placements;
                candidate = idx;
            }
        }

        Palabra p = palabras[candidate];
        double minScore = DBL_MAX;  // Start with max double value
        int bestRow = -1, bestCol = -1;

        // Find best placement position
        if (p.direction == 0) {  // Horizontal
            for (int i = 0; i < size; i++) {
                for (int j = 0; j <= size - p.largo; j++) {
                    // Check placement validity
                    int valid = 1;
                    for (int k = 0; k < p.largo; k++) {
                        char c = toupper(p.escribe[k]);
                        if (grid[i][j + k] != '.' && grid[i][j + k] != c) {
                            valid = 0;
                            break;
                        }
                    }
                    if (!valid) continue;

                    // Calculate placement score
                    double score = calculatePlacementScore(candidate, i, j);

                    // Track best position
                    if (score < minScore) {
                        minScore = score;
                        bestRow = i;
                        bestCol = j;
                    }
                }
            }
        }
        else {  // Vertical
            for (int j = 0; j < size; j++) {
                for (int i = 0; i <= size - p.largo; i++) {
                    int valid = 1;
                    for (int k = 0; k < p.largo; k++) {
                        char c = toupper(p.escribe[k]);
                        if (grid[i + k][j] != '.' && grid[i + k][j] != c) {
                            valid = 0;
                            break;
                        }
                    }
                    if (!valid) continue;

                    double score = calculatePlacementScore(candidate, i, j);
                    if (score < minScore) {
                        minScore = score;
                        bestRow = i;
                        bestCol = j;
                    }
                }
            }
        }

        // Place the word in grid
        for (int k = 0; k < p.largo; k++) {
            char c = toupper(p.escribe[k]);
            int r = bestRow + (p.direction ? k : 0);
            int c = bestCol + (p.direction ? 0 : k);
            grid[r][c] = c;
        }

        // Update tracking variables
        placed[candidate] = 1;
        placedCount++;

        // Recompute heatmap with new constraints
        recomputeHeatmap(placed);
    }

    free(placed);
}

//Key Concepts Clarification:

//    Heatmap Mechanics:

//    Each cell has 26 counters (A-Z) tracking how many words could place that letter

//    totalHeat sums all possibilities for a cell

//    When placing a word, we:

//        Lock cells to specific letters

//        Remove all possibilities that conflict with placed letters

//        Recompute possibilities for remaining words

//    Disruption Calculation:

//    Measures how many possibilities a placement would eliminate

//    For cell (r,c): disruption = totalHeat[r][c] - heatmap[r][c][current_letter]

//    Summed over all letters in the word

//    Higher disruption = more constraints imposed on other words

//    Placement Priority:

//    Words with fewer valid placements (most constrained) go first

//    Within valid placements:

//        Prefer positions causing least disruption

//        Break ties with proximity to center

//    Places most disruptive words first when they have few options

//    Dynamic Updates:

//    Heatmap recomputed after each placement

//    Only considers unplaced words

//    Automatically handles conflicts by removing invalid placements

//Example Walkthrough:

//For a 5x5 grid with word "CAT" (horizontal):

//    Initial Heatmap:

//        Row 1: C can be in columns 0-2, A in 1-3, T in 2-4

//        Cell (1,1): Could be C (from CAT@col0), A (from CAT@col1), or T (from other words)

//    Placement Selection:

//        Try CAT starting at (1,1):

//            Disruption at (1,1): total - C possibilities

//            Disruption at (1,2): total - A possibilities

//            Disruption at (1,3): total - T possibilities

//        Calculate center distance

//        Compare scores with other positions

//    After Placement:

//        Cells (1,1),(1,2),(1,3) locked to C,A,T

//        Heatmap updated:

//            Remove all placements conflicting with these letters

//            Update possibility counts for remaining words

// This approach maintains superposition of possible letters,
// places words to minimize disruption, and dynamically updates constraints without backtracking.
// The heatmap acts as a guide to resolve conflicts intelligently while preferring central positions.
